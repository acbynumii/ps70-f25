<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="styles.css">

    <title>PS70: Week 9</title>
</head>
<body>
    <!-- NAVBAR -->
    <nav>
        <div class="left">
            <a href="../index.html">PS70 Fall 2025</a>
        </div>
        <div class="right">
            <a href="../index.html">About Me</a>
            <a href="../final-project.html">Final Project</a>
        </div>
    </nav>

    <!-- MAIN CONTENT -->
    <section class="hero-section">    
        <div class="text">
            <h1>Networking and Communication</h1>
            <p>This week focused on programming a microcontroller to obtain and respond to information from a radio communication. The project includes at least one input device and one output device, demonstrating wireless communication capabilities. This assignment explores how microcontrollers can interact with remote data sources and respond to information from beyond their immediate physical environment.</p>
        </div>
    </section>

    <!-- PROJECT OVERVIEW -->
    <section class="hero-section">    
        <div class="text">
            <h1>Project Overview</h1>
            <p style="margin-bottom: 20px;">This project uses Bluetooth radio communication to wirelessly control a SCARA robotic arm with an ESP32. The system receives simple character commands from a paired device and interprets them as motion instructions. In response, the ESP32 drives stepper motors and a servo motor, allowing the robot to move and operate in real time based on the wireless input.</p>
            <p style="margin-bottom: 20px;">The main input device in this project is the Bluetooth communication interface on the ESP32, which receives single-character commands sent wirelessly from a paired device through the serial monitor. These characters represent user control inputs and are continuously read and processed in the main loop to determine the desired motion of the SCARA arm. In addition to Bluetooth, a physical limit switch on the Z-axis serves as a safety input, providing real-time positional feedback to prevent the arm from exceeding its mechanical limits. Together, these inputs allow both remote user control and local constraint checking.</p>
            <p>The outputs of the system are the actuators on the SCARA arm, including multiple stepper motors and a servo motor. Based on the Bluetooth commands received, the ESP32 drives the stepper motors to control the Z-axis motion, base rotation, and end-effector rotation, while the servo motor opens and closes the claw. The remote input directly determines the direction and magnitude of each movement, allowing the robot to respond immediately and physically to wireless user commands.</p>
        </div>
    </section>

    <!-- PHOTOS GALLERY -->
    <div class="gallery-center">
        <div class="responsive" style="max-width: 400px;">
            <div class="gallery">
                <a target="_blank" href="../images/week9_input.webp">
                    <img src="../images/week9_input.webp" alt="Input Device">
                </a>
                <div class="desc">Input Device</div>
            </div>
        </div>
        <div class="responsive" style="max-width: 400px;">
            <div class="gallery">
                <a target="_blank" href="../images/week9_output.webp">
                    <img src="../images/week9_output.webp" alt="Output Device">
                </a>
                <div class="desc">Output Device</div>
            </div>
        </div>
        <div class="responsive" style="max-width: 400px;">
            <div class="gallery">
                <a target="_blank" href="../images/week9_circuit.webp">
                    <img src="../images/week9_circuit.webp" alt="Photo of the Circuit">
                </a>
                <div class="desc">Photo of the Circuit</div>
            </div>
        </div>
    </div>
    <div class="clearfix"></div>
    <div class="divider"></div>

    <!-- VIDEOS GALLERY -->
    <div class="gallery-center" style="margin-top: 60px;">
        <div class="responsive" style="width: 37.5%; max-width: 300px;">
            <div class="gallery">
                <a target="_blank" href="../images/week9_demo.mp4">
                    <video controls>
                        <source src="../images/week9_demo.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </a>
                <div class="desc">Project Demonstration</div>
            </div>
        </div>
    </div>
    <div class="clearfix"></div>
    <div class="divider"></div>

    <!-- ARDUINO CODE -->
    <section class="hero-section">    
        <div class="text">
            <h1>Microcontroller Program Implementation</h1>
            <p>Below is the complete microcontroller code that implements the Bluetooth connection from the Serial Monitor to the ESP32.</p>
        </div>
    </section>

    <div class="code-block">
        <div class="code-title">Networking and Communication Code</div>
        <pre><code>// --- Libraries ---
#include &lt;AccelStepper.h&gt;
#include &lt;ESP32Servo.h&gt;
#include &lt;ESP32PWM.h&gt;
#include &lt;BluetoothSerial.h&gt;

/*

            Bluetooth Keyboard Control
         
            Controls z-axis stepper motor via Bluetooth input
         
            'w' - Move up
         
            's' - Move down
         
            'd' - Base Rotates CW
         
            'a' - Base Rotates CCW
         
            'c' - Claw closes
         
            'o' - Claw opens
         
            'x' - Servo Rotates CW
         
            'z' - Servo Rotates CCW
         
         */
         
         // Check if Bluetooth is available (compile-time check)
         #if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
         #error "Bluetooth is not enabled! Please run `make menuconfig` to enable it"
         #endif
         
         #if !defined(CONFIG_BT_SPP_ENABLED)
         #error "Serial Bluetooth not available! Please enable it in menuconfig"
         #endif
         
         // Create Bluetooth Serial object
         BluetoothSerial SerialBT;
         
         // Pin Assignments
         #define STEP_PIN_Z 26   // Z-axis step signal
         #define DIR_PIN_Z 25    // Z-axis direction signal
         #define STEP_PIN_S 16
         #define DIR_PIN_S 17
         #define STEP_PIN_B 12   // Base rotation step signal
         #define DIR_PIN_B 14    // Base rotation direction signal
         #define limit_switch_NO 21  // Z-axis limit switch
         
         // Define the z-axis stepper motor
         AccelStepper stepperZ(1, STEP_PIN_Z, DIR_PIN_Z);  // (Type:driver, STEP, DIR)
         AccelStepper stepperS(1, STEP_PIN_S, DIR_PIN_S);  // End-effector stepper
         AccelStepper stepperB(1, STEP_PIN_B, DIR_PIN_B);  // Base rotation stepper
         
         // Movement parameters
         const int moveSpeed = 1000;  // Steps per second when moving
         long currPositionZ = 0;
         long currPositionS = 0;
         long currPositionB = 0;
         char lastCommand = 0;        // Track last command received
         
         Servo myservo;  // create servo object to control a servo
         int pos = 0;    // variable to store the servo position
         int servoPin = 5;
         
         // Check if limit switch is pressed
         bool isLimitSwitchPressed() {
           return digitalRead(limit_switch_NO) == LOW;
         }
         
         void setup() {
           // Initialize Bluetooth Serial with device name
           SerialBT.begin("ESP32_Robot"); // Bluetooth device name (change if desired)
           
           // Optional: Also initialize regular Serial for debugging
           Serial.begin(115200);
           Serial.println("Bluetooth device ready! Pair with 'ESP32_Robot'");
           
           pinMode(STEP_PIN_S, OUTPUT);
           pinMode(DIR_PIN_S, OUTPUT);
           digitalWrite(STEP_PIN_S, LOW);
           digitalWrite(DIR_PIN_S, LOW);
           
           // Configure limit switch
           pinMode(limit_switch_NO, INPUT_PULLUP);
           
           // Configure stepper motor
           stepperZ.setMaxSpeed(500);
           stepperZ.setAcceleration(200);
           stepperZ.setSpeed(0);  // Start stopped
           
           stepperS.setMaxSpeed(800);  // Reduced speed for smoother movement
           stepperS.setAcceleration(200);  // Reduced acceleration for smoother, less jerky movement
           stepperS.setSpeed(0);
           
           stepperB.setMaxSpeed(50);
           stepperB.setAcceleration(10);
           stepperB.setSpeed(0);
           
           // Allow allocation of all timers
           ESP32PWM::allocateTimer(0);
           ESP32PWM::allocateTimer(1);
           ESP32PWM::allocateTimer(2);
           ESP32PWM::allocateTimer(3);
           
           myservo.setPeriodHertz(50);    // standard 50 hz servo
           myservo.attach(servoPin, 1000, 2000); // attaches the servo on servoPin
         
           // Initialize servo to open position (0 degrees)
           pos = 0;
           myservo.write(pos);
           delay(500);  // Give servo time to reach open position
           
         }
         
         void loop() {
           // Check for Bluetooth commands
           if (SerialBT.available()) {
             char command = SerialBT.read();
             
             if (command == 'w') {
               // Move up - check limit switch first, disable 'w' if limit switch is pressed
               if (!isLimitSwitchPressed()) {
                 currPositionZ -= 20;
                 stepperZ.moveTo(currPositionZ);
                 lastCommand = 'w';
               } else {
                 // Limit switch pressed - stop immediately by setting target to current position
                 stepperZ.moveTo(stepperZ.currentPosition());
                 currPositionZ = stepperZ.currentPosition();
                 lastCommand = 0;
               }
             }
             else if (command == 's') {
               currPositionZ += 20;
               // Move down
               stepperZ.moveTo(currPositionZ);  // Negative speed for down
               lastCommand = 's';
             }
             else if (command == 'a') {
               // Base rotate counter-clockwise
               currPositionB -= 20;
               stepperB.moveTo(currPositionB);
               lastCommand = 'a';
             }
             else if (command == 'd') {
               // Base rotate clockwise
               currPositionB += 20;
               stepperB.moveTo(currPositionB);
               lastCommand = 'd';
             }
             else if (command == 'z') {
               // End-effector rotate counter-clockwise (microstepped for smooth movement)
               currPositionS -= 100;  // Reduced from 10 to 2 for microstepping
               stepperS.moveTo(currPositionS);
               lastCommand = 'z';
             }
             else if (command == 'x') {
               // End-effector rotate clockwise (microstepped for smooth movement)
               currPositionS += 100;  // Reduced from 10 to 2 for microstepping
               stepperS.moveTo(currPositionS);
               lastCommand = 'x';
             }
             else if (command == 'o') {
               // Close servo - goes from 0 degrees to 180 degrees
               for (pos = 0; pos <= 180; pos += 3) {
                 myservo.write(pos);    // tell servo to go to position in variable 'pos'
                 delay(5);             // waits 5ms for the servo to reach the position
               }
             }
             else if (command == 'c') {
               // Open servo - goes from 180 degrees to 0 degrees
               for (pos = 180; pos >= 0; pos -= 3) {
                 myservo.write(pos);    // tell servo to go to position in variable 'pos'
                 delay(5);             // waits 5ms for the servo to reach the position
               }
             }
             else if (command == ' ') {
               // Stop (spacebar or any other key stops movement)
               // Immediately stop all steppers and sync positions
               stepperZ.stop();
               stepperS.stop();
               stepperB.stop();
               // Sync position variables with actual positions to prevent any movement
               currPositionZ = stepperZ.currentPosition();
               currPositionS = stepperS.currentPosition();
               currPositionB = stepperB.currentPosition();
               lastCommand = 0;
             }
           }
           else {
             // If no new command, continue with last command
             // This allows continuous movement while key is held
             // Only update target when stepper is close to current target to prevent shaking
             if (lastCommand == 'w') {
               // Check limit switch before continuing up movement
               if (!isLimitSwitchPressed() && abs(stepperZ.distanceToGo()) < 40) {
                 currPositionZ -= 20;
                 stepperZ.moveTo(currPositionZ);
               } else if (isLimitSwitchPressed()) {
                 // Limit switch pressed - stop immediately by setting target to current position
                 stepperZ.moveTo(stepperZ.currentPosition());
                 currPositionZ = stepperZ.currentPosition();
                 lastCommand = 0;
               }
             }
             else if (lastCommand == 's' && abs(stepperZ.distanceToGo()) < 40) {
               currPositionZ += 20;
               stepperZ.moveTo(currPositionZ);
             }
             else if (lastCommand == 'a' && abs(stepperB.distanceToGo()) < 40) {
               currPositionB -= 20;
               stepperB.moveTo(currPositionB);
             }
             else if (lastCommand == 'd' && abs(stepperB.distanceToGo()) < 40) {
               currPositionB += 20;
               stepperB.moveTo(currPositionB);
             }
             else if (lastCommand == 'z' && abs(stepperS.distanceToGo()) < 40) {
               currPositionS -= 100;  // Reduced from 10 to 2 for microstepping
               stepperS.moveTo(currPositionS);
             }
             else if (lastCommand == 'x' && abs(stepperS.distanceToGo()) < 40) {
               currPositionS += 100;  // Reduced from 10 to 2 for microstepping
               stepperS.moveTo(currPositionS);
             }
           }
           
           // Check limit switch and stop z-axis immediately if pressed while moving up
           if (isLimitSwitchPressed() && (lastCommand == 'w' || stepperZ.distanceToGo() < 0)) {
             // Stop immediately by setting target to current position
             stepperZ.moveTo(stepperZ.currentPosition());
             currPositionZ = stepperZ.currentPosition();
             lastCommand = 0;
           }
           
           // Run the stepper motor (non-blocking)
           stepperZ.run();
           stepperS.run();
           stepperB.run();
         }</code></pre>
    </div>

    <div class="clearfix"></div>
    <div class="divider"></div>

    <!-- CHALLENGES AND REFLECTION -->
    <section class="hero-section">    
        <div class="text">
            <h1>Reflection</h1>
            <p>I transitioned the final code for my robot to a bluetooth version, and the transition went smoothly. In the end, I was able to wirelessly control the robot from my laptop using the serial monitor.</p>
        </div>
    </section>

    <div class="clearfix"></div>
</body>
</html>
